{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport { EventEmitter, Component, forwardRef, ElementRef, NgZone, Input, Output, NgModule } from '@angular/core';\nimport EditorWatchdog from '@ckeditor/ckeditor5-watchdog/src/editorwatchdog';\nimport { first } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction CKEditorComponent_ng_template_0_Template(rf, ctx) {}\n\nconst ɵ0 = (val, index) => ('0' + index.toString(16)).slice(-2); // A copy of @ckeditor/ckeditor5-utils/src/uid.js\n// A hash table of hex numbers to avoid using toString() in uid() which is costly.\n// [ '00', '01', '02', ..., 'fe', 'ff' ]\n\n\nconst HEX_NUMBERS = new Array(256).fill(0).map(ɵ0);\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\n\nfunction uid() {\n  // Let's create some positive random 32bit integers first.\n  //\n  // 1. Math.random() is a float between 0 and 1.\n  // 2. 0x100000000 is 2^32 = 4294967296.\n  // 3. >>> 0 enforces integer (in JS all numbers are floating point).\n  //\n  // For instance:\n  //\t\tMath.random() * 0x100000000 = 3366450031.853859\n  // but\n  //\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n  const r1 = Math.random() * 0x100000000 >>> 0;\n  const r2 = Math.random() * 0x100000000 >>> 0;\n  const r3 = Math.random() * 0x100000000 >>> 0;\n  const r4 = Math.random() * 0x100000000 >>> 0; // Make sure that id does not start with number.\n\n  return 'e' + HEX_NUMBERS[r1 >> 0 & 0xFF] + HEX_NUMBERS[r1 >> 8 & 0xFF] + HEX_NUMBERS[r1 >> 16 & 0xFF] + HEX_NUMBERS[r1 >> 24 & 0xFF] + HEX_NUMBERS[r2 >> 0 & 0xFF] + HEX_NUMBERS[r2 >> 8 & 0xFF] + HEX_NUMBERS[r2 >> 16 & 0xFF] + HEX_NUMBERS[r2 >> 24 & 0xFF] + HEX_NUMBERS[r3 >> 0 & 0xFF] + HEX_NUMBERS[r3 >> 8 & 0xFF] + HEX_NUMBERS[r3 >> 16 & 0xFF] + HEX_NUMBERS[r3 >> 24 & 0xFF] + HEX_NUMBERS[r4 >> 0 & 0xFF] + HEX_NUMBERS[r4 >> 8 & 0xFF] + HEX_NUMBERS[r4 >> 16 & 0xFF] + HEX_NUMBERS[r4 >> 24 & 0xFF];\n}\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n\nconst ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from Angular integration (@ckeditor/ckeditor5-angular)';\nlet CKEditorComponent = /*#__PURE__*/(() => {\n  class CKEditorComponent {\n    constructor(elementRef, ngZone) {\n      /**\n       * The configuration of the editor.\n       * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html\n       * to learn more.\n       */\n      this.config = {};\n      /**\n       * The initial data of the editor. Useful when not using the ngModel.\n       * See https://angular.io/api/forms/NgModel to learn more.\n       */\n\n      this.data = '';\n      /**\n       * Tag name of the editor component.\n       *\n       * The default tag is 'div'.\n       */\n\n      this.tagName = 'div';\n      /**\n       * Fires when the editor is ready. It corresponds with the `editor#ready`\n       * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready\n       * event.\n       */\n\n      this.ready = new EventEmitter();\n      /**\n       * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`\n       * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change\n       * event.\n       */\n\n      this.change = new EventEmitter();\n      /**\n       * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`\n       * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur\n       * event.\n       */\n\n      this.blur = new EventEmitter();\n      /**\n       * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`\n       * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus\n       * event.\n       */\n\n      this.focus = new EventEmitter();\n      /**\n       * Fires when the editor component crashes.\n       */\n\n      this.error = new EventEmitter();\n      /**\n       * If the component is read–only before the editor instance is created, it remembers that state,\n       * so the editor can become read–only once it is ready.\n       */\n\n      this.initiallyDisabled = false;\n      /**\n       * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.\n       */\n\n      this.isEditorSettingData = false;\n      this.id = uid();\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      const {\n        CKEDITOR_VERSION\n      } = window; // Starting from v34.0.0, CKEditor 5 introduces a lock mechanism enabling/disabling the read-only mode.\n      // As it is a breaking change between major releases of the integration, the component requires using\n      // CKEditor 5 in version 34 or higher.\n\n      if (CKEDITOR_VERSION) {\n        const [major] = CKEDITOR_VERSION.split('.').map(Number);\n\n        if (major < 34) {\n          console.warn('The <CKEditor> component requires using CKEditor 5 in version 34 or higher.');\n        }\n      } else {\n        console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n      }\n    }\n    /**\n     * When set `true`, the editor becomes read-only.\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#member-isReadOnly\n     * to learn more.\n     */\n\n\n    set disabled(isDisabled) {\n      this.setDisabledState(isDisabled);\n    }\n\n    get disabled() {\n      if (this.editorInstance) {\n        return this.editorInstance.isReadOnly;\n      }\n\n      return this.initiallyDisabled;\n    }\n    /**\n     * The instance of the editor created by this component.\n     */\n\n\n    get editorInstance() {\n      let editorWatchdog = this.editorWatchdog;\n\n      if (this.watchdog) {\n        // Temporarily use the `_watchdogs` internal map as the `getItem()` method throws\n        // an error when the item is not registered yet.\n        // See https://github.com/ckeditor/ckeditor5-angular/issues/177.\n        editorWatchdog = this.watchdog._watchdogs.get(this.id);\n      }\n\n      if (editorWatchdog) {\n        return editorWatchdog.editor;\n      }\n\n      return null;\n    } // Implementing the AfterViewInit interface.\n\n\n    ngAfterViewInit() {\n      this.attachToWatchdog();\n    } // Implementing the OnDestroy interface.\n\n\n    ngOnDestroy() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.watchdog) {\n          yield this.watchdog.remove(this.id);\n        } else if (this.editorWatchdog && this.editorWatchdog.editor) {\n          yield this.editorWatchdog.destroy();\n          this.editorWatchdog = undefined;\n        }\n      });\n    } // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n\n\n    writeValue(value) {\n      // This method is called with the `null` value when the form resets.\n      // A component's responsibility is to restore to the initial state.\n      if (value === null) {\n        value = '';\n      } // If already initialized.\n\n\n      if (this.editorInstance) {\n        // The lock mechanism prevents from calling `cvaOnChange()` during changing\n        // the editor state. See #139\n        this.isEditorSettingData = true;\n        this.editorInstance.setData(value);\n        this.isEditorSettingData = false;\n      } // If not, wait for it to be ready; store the data.\n      else {\n        // If the editor element is already available, then update its content.\n        this.data = value; // If not, then wait until it is ready\n        // and change data only for the first `ready` event.\n\n        this.ready.pipe(first()).subscribe(editor => {\n          editor.setData(this.data);\n        });\n      }\n    } // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n\n\n    registerOnChange(callback) {\n      this.cvaOnChange = callback;\n    } // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n\n\n    registerOnTouched(callback) {\n      this.cvaOnTouched = callback;\n    } // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n\n\n    setDisabledState(isDisabled) {\n      // If already initialized.\n      if (this.editorInstance) {\n        if (isDisabled) {\n          this.editorInstance.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n        } else {\n          this.editorInstance.disableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n        }\n      } // Store the state anyway to use it once the editor is created.\n\n\n      this.initiallyDisabled = isDisabled;\n    }\n    /**\n     * Creates the editor instance, sets initial editor data, then integrates\n     * the editor with the Angular component. This method does not use the `editor.setData()`\n     * because of the issue in the collaboration mode (#6).\n     */\n\n\n    attachToWatchdog() {\n      const creator = (element, config) => __awaiter(this, void 0, void 0, function* () {\n        return this.ngZone.runOutsideAngular(() => __awaiter(this, void 0, void 0, function* () {\n          this.elementRef.nativeElement.appendChild(element);\n          const editor = yield this.editor.create(element, config);\n\n          if (this.initiallyDisabled) {\n            editor.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n          }\n\n          this.ngZone.run(() => {\n            this.ready.emit(editor);\n          });\n          this.setUpEditorEvents(editor);\n          return editor;\n        }));\n      });\n\n      const destructor = editor => __awaiter(this, void 0, void 0, function* () {\n        yield editor.destroy();\n        this.elementRef.nativeElement.removeChild(this.editorElement);\n      });\n\n      const emitError = () => {\n        this.ngZone.run(() => {\n          this.error.emit();\n        });\n      };\n\n      const element = document.createElement(this.tagName);\n      const config = this.getConfig();\n      this.editorElement = element; // Based on the presence of the watchdog decide how to initialize the editor.\n\n      if (this.watchdog) {\n        // When the context watchdog is passed add the new item to it based on the passed configuration.\n        this.watchdog.add({\n          id: this.id,\n          type: 'editor',\n          creator,\n          destructor,\n          sourceElementOrData: element,\n          config\n        });\n        this.watchdog.on('itemError', (_, {\n          itemId\n        }) => {\n          if (itemId === this.id) {\n            emitError();\n          }\n        });\n      } else {\n        // In the other case create the watchdog by hand to keep the editor running.\n        const editorWatchdog = new EditorWatchdog(this.editor);\n        editorWatchdog.setCreator(creator);\n        editorWatchdog.setDestructor(destructor);\n        editorWatchdog.on('error', emitError);\n        this.editorWatchdog = editorWatchdog;\n        this.editorWatchdog.create(element, config);\n      }\n    }\n\n    getConfig() {\n      if (this.data && this.config.initialData) {\n        throw new Error('Editor data should be provided either using `config.initialData` or `data` properties.');\n      }\n\n      const config = Object.assign({}, this.config); // Merge two possible ways of providing data into the `config.initialData` field.\n\n      const initialData = this.config.initialData || this.data;\n\n      if (initialData) {\n        // Define the `config.initialData` only when the initial content is specified.\n        config.initialData = initialData;\n      }\n\n      return config;\n    }\n    /**\n     * Integrates the editor with the component by attaching related event listeners.\n     */\n\n\n    setUpEditorEvents(editor) {\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on('change:data', evt => {\n        this.ngZone.run(() => {\n          if (this.cvaOnChange && !this.isEditorSettingData) {\n            const data = editor.getData();\n            this.cvaOnChange(data);\n          }\n\n          this.change.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n      viewDocument.on('focus', evt => {\n        this.ngZone.run(() => {\n          this.focus.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n      viewDocument.on('blur', evt => {\n        this.ngZone.run(() => {\n          if (this.cvaOnTouched) {\n            this.cvaOnTouched();\n          }\n\n          this.blur.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n    }\n\n  }\n\n  CKEditorComponent.ɵfac = function CKEditorComponent_Factory(t) {\n    return new (t || CKEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  CKEditorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CKEditorComponent,\n    selectors: [[\"ckeditor\"]],\n    inputs: {\n      config: \"config\",\n      data: \"data\",\n      tagName: \"tagName\",\n      disabled: \"disabled\",\n      editor: \"editor\",\n      watchdog: \"watchdog\"\n    },\n    outputs: {\n      ready: \"ready\",\n      change: \"change\",\n      blur: \"blur\",\n      focus: \"focus\",\n      error: \"error\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      useExisting: forwardRef(() => CKEditorComponent),\n      multi: true\n    }])],\n    decls: 1,\n    vars: 0,\n    template: function CKEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, \"ng-template\");\n      }\n    },\n    encapsulation: 2\n  });\n  return CKEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n\nlet CKEditorModule = /*#__PURE__*/(() => {\n  class CKEditorModule {}\n\n  CKEditorModule.ɵfac = function CKEditorModule_Factory(t) {\n    return new (t || CKEditorModule)();\n  };\n\n  CKEditorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CKEditorModule\n  });\n  CKEditorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule]]\n  });\n  return CKEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CKEditorModule, {\n    declarations: function () {\n      return [CKEditorComponent];\n    },\n    imports: function () {\n      return [FormsModule, CommonModule];\n    },\n    exports: function () {\n      return [CKEditorComponent];\n    }\n  });\n})();\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CKEditorComponent, CKEditorModule }; //# sourceMappingURL=ckeditor-ckeditor5-angular.js.map","map":null,"metadata":{},"sourceType":"module"}